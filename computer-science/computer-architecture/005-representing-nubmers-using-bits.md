---
title: 비트를 이용한 숫자 표현
parent: 컴퓨터 구조
nav_order: 5
date: 2025-01-31
excerpt: 정수와 실수는 이진법을 통해 비트로 표현할 수 있다. 정수는 일반적으로 2의 보수와 같은 고정 폭 형식으로 표현되며, 실수는 부호 비트, 지수, 그리고 가수를 포함하는 부동 소수점 표기법을 사용하여 넓은 범위의 값과 정밀도를 수용한다.
permalink: /computer-architecture/representing-nubmers-using-bits
---

## Table of contents
{: .no_toc .text-delta }

- TOC
{:toc}

---

## 정수를 비트로 표현하는 방법

정수를 비트로 표현하는 것은 숫자를 이진 형식으로 변환하는 것을 의미한다. 각 비트는 0 또는 1인 이진 숫자이다. 이 시스템에서 정수는 일반적으로 8비트, 16비트, 32비트 또는 64비트와 같은 고정된 비트 수로 표현되며, 이는 표현할 수 있는 값의 범위를 결정한다. 예를 들어, 8비트 표현은 부호 없는 형식으로 0부터 255까지의 정수를 인코딩할 수 있고, 부호 있는 형식으로는 -128부터 127까지의 정수를 인코딩할 수 있다. 이는 음수를 처리하기 위해 2의 보수 방식과 같은 방법을 사용한다. 이진 표현은 디지털 회로가 이진 신호로 작동하기 때문에 컴퓨터 시스템에서 정수를 효율적으로 저장하고 처리할 수 있게 해준다.

### 양수 표현

![이진수 9](/assets/images/binary.png)

양수는 이진수 형태로 나타낼 수 있다. 이진수는 0과 1 두 개의 기호만 사용하여 수를 세는 표현이다. 이 표현에서 각 비트는 2의 거듭제곱에 해당하며, 가장 오른쪽 비트는 2<sup>0</sup>(1)을 나타내고, 그 왼쪽 비트는 2<sup>1</sup>(2), 그 다음 비트는 2<sup>2</sup>(4)와 같이 계속된다. 예를 들어, 양수 9는 이진수로 1001로 표현되며, 가장 왼쪽 비트(1)는 8(2<sup>3</sup>)을 나타내고, 그 다음 비트(0)는 0(2<sup>2</sup>), 그 다음 비트(0)는 0(2<sup>1</sup>), 그리고 가장 오른쪽 비트(1)는 1(2<sup>0</sup>)을 나타낸다. 따라서 8 + 0 + 0 + 1은 9이 된다. 각 이진수는 1로 설정된 비트의 값을 합산하여 다시 10진수로 변환할 수 있다.

### 가장 작은 유효 비트와 가장 큰 유효 비트

![LSB와 MSB](/assets/images/lsb-and-msb.png)

**가장 작은 유효 비트**(**Least Significant Bit, LSB**)는 이진수에서 가장 오른쪽에 위치한 비트로, 가장 작은 값을 나타내며 전체 숫자 값에 가장 적게 기여한다. 예를 들어, 이진수 1001에서 LSB는 1이며, 이는 10진수로 1을 나타낸다. 반대로, **가장 큰 유효 비트**(**Most Signifacnt Bit, MSB**)는 가장 왼쪽에 위치한 비트로, 가장 큰 값을 나타내며 전체 숫자 값에 가장 크게 기여한다. 같은 예인 1001에서 MSB는 1로, 이는 10진수로 8을 나타낸다. LSB와 MSB의 구분은 데이터 인코딩, 오류 탐지, 디지털 신호 처리 등 다양한 응용 분야에서 중요하다. 이는 데이터가 어떻게 해석되고 처리되는지에 영향을 미치기 때문이다.

### 이진수의 덧셈

![이진수의 덧셈](/assets/images/binary-addition.png)

**이진수의 덧셈**은 컴퓨터 과학에서 기본적인 연산으로, AND와 XOR 논리 연산을 통해 수행할 수 있다. 이진 덧셈에서는 두 이진 수의 각 비트를 가장 낮은 자리수(LSB)부터 차례로 더해 나간다. XOR(배타적 OR) 연산은 캐리 비트[^carry-bit]를 고려하지 않고 두 비트의 합을 계산하는 데 사용되며, 입력의 1의 개수가 홀수일 때 1을 출력하여 두 비트의 합을 효과적으로 나타낸다. 반면 AND 연산은 두 개의 비트가 모두 1일 때 발생하는 캐리 비트를 결정하는 데 사용되며, 두 입력이 모두 1일 때만 1을 출력한다. 이진 덧셈을 수행하기 위해서는 각 비트 쌍에 XOR 연산을 적용하여 합을 구하고, AND 연산을 사용하여 캐리를 식별한 후, 이 캐리를 왼쪽으로 이동시켜 다음 높은 비트 위치에 더해야 한다. 이 과정은 모든 비트가 처리될 때까지 계속되며, 최종 이진 합을 결과로 얻는다.

[^carry-bit]:
    캐리 비트는 두 개의 이진 숫자의 합이 사용 중인 비트 수로 표현할 수 있는 최대 값을 초과할 때 발생하는 이진 숫자이다.

### 오버플로우와 언더플로우

**오버플로우**(**Overflow**)와 **언더플로우**(**Underflow**)는 계산이 저장하는 데이터 타입의 한계를 초과하는 상황을 설명한다. 오버플로우는 값이 데이터 타입이 표현할 수 있는 최대 한계를 초과할 때 발생하며, 이로 인해 잘못된 결과가 나타날 수 있다. 예를 들어, 8비트 부호 없는 정수에서 255에 1을 더하면 0으로 돌아가는 경우가 있다. 반대로 언더플로우는 값이 최소 한계 아래로 떨어질 때 발생하며, 이 경우 값이 0이나 가장 작은 표현 가능한 숫자로 반올림되는 경우가 많다. 이는 계산에서 정밀도 손실을 초래할 수 있다. 오버플로우와 언더플로우는 프로그램과 알고리즘에서 특히 수치 계산과 데이터 처리에 상당한 오류를 일으킬 수 있다.

### 음수 표현

음수를 이진수로 표현하는 방법은 일반적으로 2의 보수 방식을 사용한다. 2의 보수 방식에서 MSB는 부호를 나타내며, MSB가 0이면 양수를, 1이면 음수를 의미한다. 예를 들어, 8비트 정수에서 MSB는 부호를 나타내므로 -128부터 127까지의 값을 표현할 수 있다. 이진수의 2의 보수를 찾으려면 모든 비트를 반전시킨 후(0을 1로, 1을 0으로 변경) LSB에 1을 더해야 한다. 예를 들어, 8비트 시스템에서 -3을 표현하려면, 먼저 3의 이진 표현인 00000011에서 시작하여 비트를 반전시켜 11111100을 얻고, 여기에 1을 더하여 11111101이 된다. 이 방법은 덧셈과 뺄셈을 음수에 대한 특별한 처리 없이 수행할 수 있게 하여 간단한 산술 연산을 가능하게 하며, 컴퓨터 하드웨어 설계를 단순화하는 데 기여한다.

## 실수를 비트로 표현하는 방법

### 고정소수점 표현법

![고정소수점](/assets/images/fixed-point.png)

**고정소수점**(**Fixed-point**) 표현은 실수를 소수점 앞과 뒤에 고정된 숫자를 유지하는 방식으로 인코딩하는 방법이다. 이 표현은 임베디드 시스템이나 디지털 신호 처리와 같은 자원이 제한된 컴퓨터 시스템에서 일반적으로 사용되는데, 이는 효율적인 산술 연산과 예측 가능한 메모리 사용을 가능하게 하기 때문이다. 고정소수점 표현에서는 소수점의 위치가 미리 정해져 있고 변경되지 않기 때문에 계산이 단순해지지만, 표현할 수 있는 숫자의 범위와 정밀도가 제한된다. 예를 들어, 16비트의 고정소수점 형식에서는 정수 부분에 특정 비트 수가 할당되고, 나머지 비트는 소수 부분에 할당되어 정의된 정밀도로 특정 값의 범위를 표현할 수 있게 된다.

### 부동소수점 표현법

![고정소수점](/assets/images/floating-point.png)

**부동소수점 표현**(**Floating-point**)은 컴퓨팅에서 분수 부분을 포함할 수 있는 실수를 표현하는 방법이다. 이는 유한한 비트 수로 넓은 범위의 값을 표현할 수 있도록 해준다. 일반적으로 세 가지 주요 구성 요소(비트, 지수, 유효 숫자)로 구성된 형식으로 구조화된다. 부호 비트는 숫자가 양수인지 음수인지를 나타내고, 지수는 숫자의 크기나 규모를 결정하며, 유효 숫자는 숫자의 정밀도를 나타낸다. 이러한 표현 방식은 컴퓨터가 매우 크거나 매우 작은 숫자를 효율적으로 처리할 수 있게 해주지만, 산술 연산을 수행할 때 반올림 오류와 정밀도 제한과 같은 문제를 발생시키기도 한다. IEEE 754 표준은 컴퓨터 시스템에서 부동 소수점 산술을 위한 가장 보편적으로 사용되는 사양이다.

## 이진수의 다양한 표현법

### BCD

**이진 코드 십진수**(**Binary-Coded Decimal, BCD**)는 십진수를 표현하기 위해 사용되는 이진 인코딩 방식이다. 이 방식에서는 십진수의 각 자리가 각각의 이진수로 개별적으로 표현된다. BCD에서는 십진수 숫자 0부터 9까지가 네 비트를 사용하여 인코딩되며, 이는 십진수와 이진수 형식 간의 간단한 변환을 가능하게 한다. 예를 들어, 십진수 45는 BCD로 0100 0101로 표현되며, 여기서 0100은 십진수 4에 해당하고 0101은 십진수 5에 해당한다. BCD는 디지털 시계, 계산기, 금융 시스템 등과 같이 정확한 십진수 표현이 필요한 응용 프로그램에서 특히 유용하다. 이는 순수 이진 표현에서 발생할 수 있는 반올림 오류의 위험 없이 이진수와 십진수 간의 변환 과정을 간소화하기 때문이다.

### 8진 표현법

**8진 표현법**(**Octal Representation**)은 8을 기반으로 하는 숫자 체계로, 0부터 7까지의 숫자를 사용한다. 각 8진수 숫자는 3개의 비트 그룹에 해당하여, 이진수를 더 간결하게 표현하는 편리한 방법이 된다. 예를 들어, 이진수 101101은 두 개의 3비트 집합으로 그룹화될 수 있다: 010(8진수로 2)와 101(8진수로 5)로, 결과적으로 8진수 표현은 25가 된다. 여러 프로그래밍 언어에서 0으로 시작하는 숫자는 8진 숫자다. 예를 들어, 017은 8진수이며 값은 10진수로 15다. 이 시스템은 컴퓨팅과 디지털공학에서 특히 유용하며, 이진수와 더 인간이 읽기 쉬운 형식 간의 변환을 간소화하면서도 이진 값과 밀접한 관계를 유지한다. 유닉스와 리눅스에서는 프로그래밍 및 파일 권한은 8진수 형식으로 표현된다.

### 16진 표현법

**16진 표현법**(**Hexadecimal Representaion**)은 16개의 고유한 기호를 사용하는 16진수 시스템이다. 숫자 0부터 9는 값 0에서 9를 나타내고, 문자 A부터 F(또는 a부터 f)는 값 10에서 15를 나타낸다. 각 16진수 자리는 4비트 이진수 시퀀스에 해당하여 이진 데이터를 간결하게 표현하는 방법이 된다. 예를 들어, 16진수 숫자 "1A3"는 각 자리를 변환하여 이진수로 변환할 수 있다: '1'은 0001, 'A'는 1010, '3'은 0011로, 결과적으로 이진수 표현은 000110100011이 된다. 여러 프로그램 언어에서 0x가 앞에 붙은 숫자는 16진수다. 예를 들어, 0x12f는 16진수이며 값은 10진수 303이다. 16진수와 이진수 간의 이러한 관계는 컴퓨팅 및 디지털공학에서 특히 유용하며, 큰 이진수를 표현하는 것을 단순화하여 읽고 조작하기 쉽게 만든다.